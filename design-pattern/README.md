# 工厂模式
* 使用Bean的代码 不再关注Bean的创建
* Ban的创建由特定的工厂来独立完成，提升效率
* 降低使用方和创建方的耦合程度
* 几种实现的对比
    * 简单工厂
        * 所有的判断选择逻辑由工厂类来完成
        * 当新增业务的时候需要修改工厂类
    * 工厂方法
        * 工厂类与实际提供者是接口实现的关系，将选择的过程交给类调用者
        * 需要调用者自己选择实际调用类
    * 抽象工厂
        * 在抽象工厂中定义了所有的支持
        * 抽象工厂与实现，是接口和实现的关系
        * 调用这，只需要从工厂类中选择即可

# 单例模式
* 使用内部类实现
* 使用锁实现
* 使用枚举
* 使用线程安全数据结构实现

# 原型模式
* 通过对对象的复制，来实现对象的实例化
* 存在一个深复制和浅复制的问题
* java的原生clone方法的效率要比new的高

# 代理模式
* 角色分为 代理角色(proxy)+被代理角色(target)
* 静态代理，会有硬编码，受限于硬编码，不利于扩展，只能固定的代理某个功能
* jdk动态代理，依赖于InvocationHandler的invoke方法的实现，来进行代理操作
    * jdk动态代理，基于接口实现
    * jdk动态代理，生成的proxy无法强转为target类型
    * jdk动态代理，基于反射，sun的技术
* cglib动态代理，依赖于MethodInteceptor的intercept方法的实现，来进行代理操作
    * cglib动态代理，基于字节码实现 
    * cglib动态代理，生成的proxy可以转换为target类型
    * cglib动态代理，基于spring的，需要增加spring-core的依赖
    
# 策略模式
* 先定义接口行为，可通过匿名内部类的实现方式，动态的控制实际的执行行为
    * 排序，匿名实现Comparator接口，在排序时传入，动态的控制排序规则
    
# 模版模式

# 委派模式
* 角色有 调用发起者，请求的转发者，实际的请求处理者
* 类似代理模式
    * 转发者接收了所有的调用发起，并根据一定的考量标准，转发给实际的执行之
    * 代理模式侧重与功能的增强，而这里只是转发
* 类似与策略模式
    * 请求的实际处理者，是有一定的选择性的。
    * 策略模式更加侧重策略的扩展行，而这里的调用方是固定的

# 适配器模式
* 更多的关注，在不改动原有代码的前提下，进行功能的扩展

