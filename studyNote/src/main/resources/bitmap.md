# bitmap

* count bit
    * 一串01序列，如何知道有多少个1 ？？？
    * 科普知识，知道的可忽略
        * [汉明距离](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/475174)
            * 俩个等长的字符串，对应位置字符不一样的个数
        * [汉明重量](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F/7110799)
            * 一串符号中非0符号的个数
            * 等同于 和 同样长度的全零符号串 的 汉明距离
            > 所以count bit问题，就是计算汉明重量问题！！！
    * 如何算(下面只写网页上没有的，也就是自己理解网页上资料的过程)
        * SWAR算法
            * 一、原始数据：A = 0 1 1 0 1 1 0 0 1 0 1 1 1 0 1 0
            * 二、B = A & （01 01 01 01 01 01 01 01）
                * 将a的数据2个二进制位为一组，与01相&，得到结果B
                * B中的 每2个二进制位 的 低位 就会记录 原始A的每2个二进制位 的 `低位`，如果是1保留，不是则丢弃（认真读，多读几次）
            * 三、C = (A>>1) & (01 01 01 01 01 01 01 01)
                * 将a的数据右移一位
                    * 上一步操作基于 每2个二进制位，但是只处理了低位，向右移动一位，则将高位变成了低位（看懂了再继续向下读）
                * C中的 每2个二进制位 的 低位 就会记录 原始A中每2个二进制位 的 `高位`, 如果是1保留，不是则丢弃(认真读，多读几次)
            * 四、D = B + C
                * 经过二和三，将 每2个二进制位 中的1 全部移动到了低位
                * 将B 和 C 相加 ，此时 每2个二进制位 的结果有如下意义
                    * 如果00，代表一个1都没有
                    * 如果01，代表有一个1
                    * 如果10，代表有二个1
                    * 不会出现11
                * 实现了高位1的个数，用低位的值来表示的效果（如果有豁然开朗的感觉可以继续，如果没有请从头再来）
            > 上面的二、三、四过程 已经实现了 每2个二进制位 中1的个数的统计。（将高位的1移动到低位，1的意思不再是2的x次幂，变成了数值1，实现统计功能）
            * 五、E = D & (0011 0011 0011 0011)
                * 将 四个二进制组合在一起和 0011 做&操作，保留低俩位中记录的1的个数
            * 六、F = (D >> 2) & (0011 0011 0011 0011)
                * 将 四个二进制位的高位中记录的1的个数，放到低俩位
            * 七、G = E + F
                * 每四个二进制位的，低俩位记录原始四个二进制位中1的个数
            > 上面的五、六、七过程 与二、三、四类似，从宏观上看实现了 高位1的个数 向 低位的变化，循环往复，即可以O(1)的时间复杂度获取1的个数
        * 其他变种
            * 此处举个特例`x = 010000100000001000000`
                * 上述例子中0的个数要远大于1的个数
                * y = x & x-1 将会把最低位的1直接消除
                * 循环x次，直到结果为0，次数就是1的个数
    * 看看java怎么搞的
        * `java.util.BitSet#cardinality` -> `java.util.Long#bitCount`
        * 代码如下
            * ```java
                public static int bitCount(long i) {
                    // HD, Figure 5-14
                    i = i - ((i >>> 1) & 0x5555555555555555L);
                    i = (i & 0x3333333333333333L) + ((i >>> 2) & 0x3333333333333333L);
                    i = (i + (i >>> 4)) & 0x0f0f0f0f0f0f0f0fL;
                    i = i + (i >>> 8);
                    i = i + (i >>> 16);
                    i = i + (i >>> 32);
                    return (int)i & 0x7f;
                }
              ```     
        * 难点分析
            * 第一行 `i - ((i>>>1) & 0x5555555555555555L)`
                > 笔者也和阅读文本的你一样，花式懵逼，完全不懂，直到找到[这个文章](https://juejin.cn/post/6844904098123218957#heading-7)
                * 文章中提到一个观点(针对Integer进行的分析) 
                    * i - ( (i>>>1) & 0x55555555 ) = i & 0x55555555 + (i>>>1) & 0x55555555
                    * i = i & 0x55555555 + (i>>>1) & 0x55555555 << 1 (左移动相当于*2)
                    * i & 0x55555555 相当于i的奇数位的值
                    * (i>>>1) & 0x55555555 相当于i的偶数位的值
                    * 上述俩个式子的和确实是i
                * 个人观点
                    * 上述分析成立的前提是基于一定前提的，把i看成多个 俩个二进制位 的组合，且移位距离为1
                        * 从后续的计算使用加法而不使用减法可以得到佐证
                    * 再分析为什么俩个二进制位移动一位的时候，式子是成立的呢？
                        * 问题抽象其实就是俩个二进制位的这种运算是相等的
                        * 穷举
                            > 每种情况，对减法和加法俩种方式进行了一个对比
                            * 11
                                * 11 - (11 >>> 1) & 01  = 11 - 01 = 10   
                                * 11 & 01 + 01 & 01     = 01 + 01 = 10
                            * 10
                                * 10 - (10 >>> 1) & 01  = 10 - 01 = 01 
                                * 10 & 01 + 01 & 01     = 00 + 01 = 01
                            * 01
                                * 01 - (01 >>> 1) & 01  = 01 - 00 = 01
                                * 01 & 01 + 00 & 01     = 01 + 00 = 01
                            * 00
                                * 00 - (00 >>> 1) & 01  = 00 - 00 = 00 
                                * 00 & 01 + 00 & 01     = 00 + 00 = 00
                            * 结论
                                * 我自认为这仅仅是一个巧合，减法运算的结果的十进制值 刚好可以表示 俩个二进制位中1的个数 
                                * 这个结论仅仅在移动一位的情况生效，移动一位就相当于俩个相邻二进制位的上述计算过程。如果移动二位或者更多位将没有任何意义
            * 最后一行`return (int)i & 0x7f;`
                * 0X7f的二进制形式，1111111，10进制为127，long类型数据 8字节，64位，最多64个1，0x7f足矣
        * 其余部分的思路和计算方式与SWAR的思想是完全一致的
    * 总结
        * SWAR算法，虽然是对二进制位的一种处理，但分析本质还是分而治之的思想，将很长的二进制位，俩俩分组，然后结果汇总。
        * 时间复杂度为logN，但如果N的长度固定的话，也可以理解为O(1)
                    