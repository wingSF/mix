# bitmap

* count bit
    * 一串01序列，如何知道有多少个1 ？？？
    * 科普知识，知道的可忽略
        * [汉明距离](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E8%B7%9D%E7%A6%BB/475174?fr=aladdin)
            * 俩个等长的字符串，对应位置字符不一样的个数
        * [汉明重量](https://baike.baidu.com/item/%E6%B1%89%E6%98%8E%E9%87%8D%E9%87%8F/7110799?fr=aladdin)
            * 一串符号中非0符号的个数
            * 等同于 和 同样长度的全零符号串 的 汉明距离
    * 所以count bit问题，就是计算汉明重量问题！！！
    * 如何算(下面只写网页上没有的，也就是自己理解网页上资料的过程)
        * SWAR算法
            * 一、原始数据：A = 0 1 1 0 1 1 0 0 1 0 1 1 1 0 1 0
            * 二、B = A & （01 01 01 01 01 01 01 01）
                * 将a的数据2个二进制位为一组，与01相&，得到结果B
                * B中的 每2个二进制位 的 低位 就会记录 原始A的每2个二进制位 的 `低位`，如果是1保留，不是则丢弃（认真读，多读几次）
            * 三、C = (A>>1) & (01 01 01 01 01 01 01 01)
                * 将a的数据右移一位
                    * 上一步操作基于 每2个二进制位，但是只处理了低位，向右移动一位，则将高位变成了低位（看懂了再继续向下读）
                * C中的 每2个二进制位 的 低位 就会记录 原始A中每2个二进制位 的 `高位`, 如果是1保留，不是则丢弃(认真读，多读几次)
            * 四、D = B + C
                * 经过二和三，将 每2个二进制位 中的1 全部移动到了低位
                * 将B 和 C 相加 ，此时 每2个二进制位 的结果有如下意义
                    * 如果00，代表一个1都没有
                    * 如果01，代表有一个1
                    * 如果10，代表有二个1
                    * 不会出现11
                * 实现了高位1的个数，用低位的值来表示的效果（如果有豁然开朗的感觉可以继续，如果没有请从头再来）
            > 上面的二、三、四过程 已经实现了 每2个二进制位 中1的个数的统计。（将高位的1移动到低位，1的意思不再是2的x次幂，变成了数值1，实现统计功能）
            * 五、E = D & (0011 0011 0011 0011)
                * 将 四个二进制组合在一起和 0011 做&操作，保留低俩位中记录的1的个数
            * 六、F = (D >> 2) & (0011 0011 0011 0011)
                * 将 四个二进制位的高位中记录的1的个数，放到低俩位
            * 七、G = E + F
                * 每四个二进制位的，低俩位记录原始四个二进制位中1的个数
            > 上面的五、六、七过程 与二、三、四类似，从宏观上看实现了 高位1的个数 向 低位的变化，循环往复，即可以O(1)的时间复杂度获取1的个数
        * 其他变种
            * 此处举个特例`x = 010000100000001000000`
                * 上述例子中0的个数要远大于1的个数
                * y = x & x-1 将会把最低位的1直接消除
                * 循环x次，知道结果为0，那x就是1的个数
                    