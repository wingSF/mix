# jdk1.6锁优化
## Synchronized
* 优化前
    * Synchronized如果加在代码段，使用的是monitor enter和monitor exit指令
    * Synchronized如果加在方法，通过给方法增加一个ACC_SYNCHRONIZED标识
    * 弊端
        * java线程会映射到操作系统的原生线程上，对线程的挂起和唤醒都需要操作系统来完成，即需要用户态向内核态进行转变

* 优化的理论依据
    * 共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得
    * 单核情况下，锁等待可能无效；但是双核或者多核心的情况下，是存在并行线程的，这个时候某个核上的线程自旋会等待别的核上的线程释放共享资源是有可能的
    * 优势
        * 避免了线程切换的开销
    * 劣势
        * 增加cpu的时间片占用
            * 自旋锁:如果占用锁资源的时间较长，则会导致很多次无效果的自旋，可以通过配置修改默认的次数（10次）
                * 适应性自旋锁:改进办法，使用自适应的自旋锁，自旋次数由上次自旋次数决定

* 优化后
    * 减少锁的开销
        * 偏向锁/轻量级锁/自旋锁/适应性自旋锁/锁消除/锁粗化
    * 锁消除
        * 即时编译发现资源没有竞争的情况下，会直接消除同步
            * ex:堆上的数据，都不会逃逸出去被别的线程访问到，那么就是相当于是线程私有的
    * 锁粗化
        * 在一段代码中，出现了多个地方频繁加锁解锁的情况，或者在循环体内部进行加锁操作，这个时候为了减少加锁的次数，虚拟机会对锁的范围进行扩大
        * 前提条件，本来没有线程竞争的地方，却频繁的加锁，虚拟机会对其进行优化，即锁范围扩大
    * 锁状态
        * 无锁/偏向锁/轻量级锁/重量级锁
        * 以上是随着竞争，锁升级的过程，锁不可降级
        * 这样做的目的是提高获得锁和释放锁的效率
    * 自旋锁/适应性自旋锁
        * 参见上面优化的理论依据中的劣势部分的解释
    * 偏向锁/轻量级锁/重量级锁
        * 重量级锁:使用操作系统的互斥量来实现的传统锁，低效
        * 轻量级锁:相对与重量级锁来说，没有采用互斥量来实现，而是通过cas修改锁即java对象的对象头来实现的一种资源占有方式
            * 理论依据:对于同一个锁，在整个同步周期内都是不存在竞争的
            * [java对象头](https://www.jianshu.com/p/3d38cba67f8b)
                * 是java对象的额外存储成本
                * 用来记录对象的hashcode，gc年龄，锁标志状态，如果是数组对象，还会存储数组的长度
                    * 锁标志状态
                        * 01 无锁
                        * 00 轻量级锁
                        * 10 重量级锁
                        * 11 GC标记
                        * 01 可偏向
            * 过程
                * 线程先将java对象头中的内容复制到当前线程的栈空间中，记为Lock Record
                * 然后cas方式尝试将对象头指向该Lock Record记录
                * 修改对象头中的锁标志位00，表示该对象被轻量级锁定
                * 如果有俩个线程争抢该对象，将变成10，对象头当中存储指向互斥量的指针，其它线程阻塞
                * 解锁过程也是cas替换，将Lock Record更新回对象头，如果成功，则结束，如果失败，则说明有线程被block，需要唤醒//todo 如何唤醒的
            * 作用
                * 减少没有竞争的情况下，锁的性能消耗
        * 偏向锁
            * 理论依据:数据无竞争的状态下，是不需要cas操作的
            * 过程
                * 线程先将java对象头中的内容复制到当前线程的栈空间中，记为Lock Record
                * 然后cas方式尝试将线程id存放到对象头中
                * 修改对象头中的锁标志位01
                * 之后该线程再次进入同步代码段中，不会有任何同步操作
                * 当别的线程尝试获取锁，偏向模式结束,
            * 作用
                * 提供同步但无竞争情况下的效率
                
            
                        
        
        
    