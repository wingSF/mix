# 小文件合并项目总结
* 背景
    * 在大数据的dfs中，存在着很多大小特别小的文件，这些文件会影响hadoop的计算性能，考虑写一个分布式的任务调度程序，将这些小文件合并成一个大文件，期间踩坑无数，有的已经蹚平，有的仍需研究，终于有时间，做一记录，以总结最近的所见所得所思所想。
* 涉及技术点
    * 线程池
        * 线程池选型
            * ```Executors``` 提供的 ```newFixedThreadPool```，```newCachedThreadPool```有诸多不确定点，建议结合自己的实际情况使用
                * newFixedThreadPool
                    * 队列使用了```new LinkedBlockingQueue<Runnable>()```的申明方式，就决定了该队列的最大值为```Integer.MAX_VALUE```.
                    > 这里只说有问题的场景，当线程的处理能力达到瓶颈时，队列会一直堆积元素到Integer的最大值，可能会发生OOM  
                    参考 arithmetic工程下FixedThreadPoolDemo.java文件
                * newCachedThreadPool
                    * 核心线程数为0，最大线程数使用```Integer.MAX_VALUE```的申明方式，会导致线程在使用的时候才会创建，且无上限，而且当线程池休息的时候，只要超过timeout会kill掉所有线程
        * 线程池队列选型
            * 可参见 arithmetic工程下的 queueDemo包
            * 在决定自己继承```ThreadPoolExecutor```实现线程池的时候发现，线程池的队列申明是```BlockingQueue```，疑问有二
                * 为什么是阻塞队列
                    * 这个问题，一拍脑袋，非阻塞一定比阻塞效率要高，所以百思不得其解。最终反问了自己一下，如果队列中元素为空了，这个时候线程应该怎么做，会发现，非阻塞队列的时候，如果一直pull元素，cpu会高居不下...
                * 为什么要把Deque排除
                    * 不得解不得解//todo
                    * Deque有俩头操作的特性，可用于工作窃取，这样当前线程从头向尾工作，别的线程可以从尾巴部位，偷取几个任务，互不干涉。
        * 线程池worker的理解
            * execute
                * 方法的参数是```Runnable```,该接口中有一个抽象方法是```run```方法，Thread类实现了该接口
                * 当一个Runnable的子类对象被提交之后，会将该对象以offer的方式添加到workQueue中(查看execute的源码可得)
                * ```workerCountOf(c) < corePoolSize```如果线程数小于核心线程数，则创建线程执行该任务```addWorker(command, true)```
                * 注意```#addWorker```的第二个参数，为true时，是核心线程数，为false时，是最大线程数
                * 调用```#addWorker```有三个场景，上面提到一个参数为true的场景，另外俩个分别是
                    * 当任务添加队列成功的时候，会再次检测是否有可用的线程，因为线程可能会因为idle时间过程被clean掉|线程池已经shut down，此时会增加worker，且参数为false
                    > 该逻辑很少被人提及，还是要自己看啊.....这个地方有注释，可以参考
                    * 当任务添加队列失败的时候，会创建worker，参数为false，如果创建失败，则调用拒绝策略
                * 说完了调用```#addWorker```，说说这个方法内部，一大坨逻辑啊//todo
            * submit
                * 方法的参数也是```Runnable```,该方法位于```AbstractExecutorService```中，重载的方法有三个，参数分别是```(Runnable)| (Runnable，Result)| (Callable)```
                * 之后会通过该抽象类的```#newTaskFor```方法，把请求封装成```RunnableFuture```对象，然后提交给workQueue，然后执行上面execute的逻辑
            * 认知理解
                * 以前一直将线程和任务这俩个东西混为一谈，但实际上，线程是一个操作系统分配的用来执行任务的资源，而任务才是真正的业务逻辑，所以使用Thread类，将业务写在run方法里面，是不合理的。
                * 所以出现了线程池的概念，线程池用来维护工作的资源，不关心你实际执行任务的内容。任务自己去实现```Runnable```接口，然后将任务提交到线程池。这样做到各司其职，边界清晰。
        * 线程池task cancel/interrupted理解
        * 线程池的运行机制
            * submit与execute的区别
        * 实践经验部分
            * 批量提交任务后的超时控制方式
    * springboot中的config配置/bean配置/propertySource
    * spring Schedul调度
        * fixRate/fixDelay
        * 以及fixDelay未生效后，使用atomicBoolean做的补救措施
    * httpclient
        * 返回stream的处理与连接的关系，以及try-with-stream的处理方式
    * 分布式任务的领取一致性处理方式
        * mysql update加where条件+状态机转换
    * 文件超过
        * guava Files
            * asByteSink
                * 文件路径错误导致流未消费问题，进而引发链接耗尽
            * readLines
                * 将整个文件读入内存进行操作，引发的OOM问题
    * log4j2的日志配置
    