# InnoDB表空间
* 表空间对应磁盘上的一个或多个`.ibd`实际文件
* 表空间里面，通过`B+树`的形式将`页`组织起来
* 表空间里面，有很多的`页`组成
* 页
    * 16KB
        * 通用部分
            * File Header 38字节
            * File Trauler 8字节
* 区
    * 由于页的数量很很多，将连续的64个页放在一起，组成一个`区`,注意是连续的页，那将来就是顺序io喽  
    * 每256个区，组成一个`组`
    * 分类
        * 没有用到这个区中的任何页面
        * 碎片区还有可用的页面
        * 碎片区所有页面都被使用，没有空闲页面
        * 附属于某个段的区
    * 为了管理区，设计的XDES Entry
        * segmentId
            * 归属段的id
        * listNode
            * prev node page number & prev node offset
            * next node page number & next node offset
            * 可以通过page number+offset找到上一个或下一个区
        * state
            * 页状态标识位
                * 归属某个段
                * 碎片区满了
                * 碎片区没满
                * 未使用
        * page state bitmap
            * 128个比特位，每2位一组，64组，用来标识区里面的64页面是否被使用
* 组
    * 第一个组的前三个页面
        * FSP_HDR
            * 记录整个表空间的一些整体属性
            * 记录本组所有的区的属性
            * 整个表空间只有一个FSP_HDR类型的页
        * IBUF_BITMAP
            * 存储本组所有的区的所有页面关于Insert Buffer的信息
        * INODE
            * todo
    * 其余组的前俩个页面
        * XDES
            * 记录本组256个区的属性
        * IBUF_BITMAP
            * 同上
* 段
    * 用来区分叶子节点和非叶子节点，所以一个索引树，有俩段，叶子段|非叶子段
    > 在范围查询的时候，同时家在叶子节点和非叶子节点有性能浪费
* 碎片区
    * 碎片区直接属于表空间，不属于某个段
    * 碎片区中的页可以用于不同的段
    * 有的数据不会写满一个区，所以设计碎片区
        * 新插入数据，先写碎片区
        * 当占用32个碎片区页面之后，以完整的区来分配存储空间，一次64个页，1M