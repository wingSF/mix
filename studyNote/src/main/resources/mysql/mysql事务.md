# 事务
* 原子性
    * 最小工作单元，一组不可分割的操作集合，要么全成功，要么全失败
* 一致性
    * 
* 隔离性
    * 一个事务所操作的数据在提交之前，对其它事务的可见性
* 持久性
    * 事务一旦提交对数据的变更是持久的
    
# 事务隔离级别
* Read UnCommitted
    * 能读到对方未提交的数据
* Read Committed
    * 一个事务内，能读到别的事务提交的数据
* Repeatable Read
    * 一个事务内，重复执行同样的sql，得到相同的结果
* Serializable
    * 事务，串行执行
    
# 几个概念
* 脏读
    * 读到其它事务未提交的数据
* 不可重复读
    * 一个事务内，俩次执行，发现单个数据的结果是不一致的
    * 中间该数据被别的事务进行了修改
* 幻读
    * 一个事务内，第一次读取不存在的数据，第二次读发现存在了
    * 常见与select无结果，但是insert的时候发现主键重复
    
> oracle 默认隔离级别Read Committed，术语RC  

| DATABASE_ISOLATION | 脏读 | 不可重复读 | 幻读
| - | :-: | -: |  -: | 
| Read UnCommitted | 可能 | 可能 |  可能 | 
| Read Committed | 不可能 | 可能 |  可能 | 
| Repeatable Read | 不可能 | 不可能 |  对Innodb不可能，别的可能 | 
| Serializable | 不可能 | 不可能 |  不可能 | 

# 锁
* 通过锁保证不出现不可重复读/幻读
* 意向锁（共享/排他）// todo 待深入明确
    * 是innodb中的锁机制
* 共享锁（Share->s锁，别称:读锁）
    * 多个事务只能读，不能写
* 排他锁（eXclusive->x锁,别称:写锁）
    * 事务独占，其它事务获取只能读快照
* 自增锁
    * //todo 待深入理解
* 记录锁
    * 从索引列锁住唯一的记录
* 间隙锁
    * 锁住一个区间
* 临键锁
    * 间隙锁+记录锁
    
* undo log
    * 在事务开始之前，把要操作的数据写入undo log，用于后续回滚或者快照读
* redo log
    * mysql事务提交成功的标准是，写入redo log记录，根据一定规则将redo log刷新到物理数据文件中
* mvcc
    * 解决了在无锁状态下的脏读/不可重复读/幻读
    * 多版本并发控制
        * 事务每次开启都会获得一个id，是增长的
    * 插入
        * 每行数据多增加三列数据，1数据行的版本号2删除的版本号（默认null）3伪列（与mvcc无关）
    * 删除
        * 选中数据，将删除版本号改为当前事务id
    * 修改
        * 先复制选中数据，将原始记录的删除版本号改为当前版本号
        * 新记录的数据版本为当前事务id，删除版本号为null
    * 查询
        * 查询数据行版本号小于当前事务id的行数据（保证不幻读）
            * 保证读取到的数据是事务开启前的数据
        * 删除版本号为null，或者删除版本号大于当前事务id（保证不读脏）
            * 保证读取到的数据没被删除，或者是被后续事务删除的


    