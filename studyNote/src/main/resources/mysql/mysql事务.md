# 事务
* 原子性
    * 最小工作单元，一组不可分割的操作集合，要么全成功，要么全失败
* 一致性
    * 
* 隔离性
    * 一个事务所操作的数据在提交之前，对其它事务的可见性
* 持久性
    * 事务一旦提交对数据的变更是持久的
    
# 事务隔离级别
* Read UnCommitted
    * 能读到对方未提交的数据
* Read Committed
    * 一个事务内，能读到别的事务提交的数据
* Repeatable Read
    * 一个事务内，重复执行同样的sql，得到相同的结果
* Serializable
    * 事务，串行执行
    
# 几个概念
* 脏读
    * 读到其它事务未提交的数据
* 不可重复读
    * 一个事务内，俩次执行，发现单个数据的结果是不一致的
    * 中间该数据被别的事务进行了修改
* 幻读
    * 一个事务内，第一次读取不存在的数据，第二次读发现存在了
    * 常见与select无结果，但是insert的时候发现主键重复
    
> oracle 默认隔离级别Read Committed，术语RC  

| DATABASE_ISOLATION | 脏读 | 不可重复读 | 幻读
| - | :-: | -: |  -: | 
| Read UnCommitted | 可能 | 可能 |  可能 | 
| Read Committed | 不可能 | 可能 |  可能 | 
| Repeatable Read | 不可能 | 不可能 |  对Innodb不可能，别的可能 | 
| Serializable | 不可能 | 不可能 |  不可能 | 

# 锁
* 通过锁保证不出现不可重复读/幻读
* 意向锁（共享/排他）
    * 表级锁
    * 是innodb中的锁机制
* 插入意向锁
    * 行级锁
    * 只有在插入的时候才会使用
    * 俩个插入意向锁之间不会冲突，但会和gap/next-key 冲突，就是基于这个原理，搞定了幻读问题
    * 一个事务如果获取了插入意向锁，不影响任何别的事务加任何锁
    * 一个事务尝试获取插入意向锁，会被gap/next-key阻塞
* 共享锁（Share->s锁，别称:读锁）
    * 多个事务只能读，不能写
* 排他锁（eXclusive->x锁,别称:写锁）
    * 事务独占，其它事务获取只能读快照
* 自增锁
    * //todo 待深入理解
* 记录锁
    * 从索引列锁住唯一的记录
* 间隙锁
    * 锁住一个区间
    * RR隔离级别下，修改一个不存在的数据，会锁住这个记录应该在的前后俩个索引中间的范围
    * 间隙锁只会阻塞插入意向锁，不会阻塞别的锁
* 临键锁
    * 间隙锁+记录锁
    * 左开(gap)+右闭(record)
    * RR隔离级别下，修改一个的数据，根据where条件命中非唯一索引，会将记录加x锁，记录前后加gap锁
* 自增锁
    * auto_increment带来的锅
    * 远古时期，都是mysql维护自增的
    * 后来有个配置`innodb_autoinc_lock_mode`
        * 0:采用远古方案
        * 2:全部采用新方案，相对于远古时期的自增锁，是一个轻量级的自增锁，为数据库主从数据不一致[埋下了雷](//todo)
        * 1:根据insert sql插入数据量的情况分三种
            * 1.1:simple inserts 明确知道插入数据量
            * 1.2:bulk inserts 无法知道插入数量
            * 1.3:mixed-mode inserts 有的有自增值，有的没有 insert...on duplicate key update
            > 1.1和1.3使用轻量级自增锁，1.2远古自增锁
* 锁查看
    * select * from infomation_schema.innodb_locks
    * select * from infomation_schema.innodb_lock_waits
* undo log
    * 在事务开始之前，把要操作的数据写入undo log，用于后续回滚或者快照读
* redo log
    * mysql事务提交成功的标准是，写入redo log记录，根据一定规则将redo log刷新到物理数据文件中
* mvcc
    * 解决了在无锁状态下的脏读/不可重复读/幻读
    * 多版本并发控制
        * 事务每次开启都会获得一个id，是增长的
    * 插入
        * 每行数据多增加三列数据，1数据行的版本号2删除的版本号（默认null）3伪列（与mvcc无关）
    * 删除
        * 选中数据，将删除版本号改为当前事务id
    * 修改
        * 先复制选中数据，将原始记录的删除版本号改为当前版本号
        * 新记录的数据版本为当前事务id，删除版本号为null
    * 查询
        * 查询数据行版本号小于当前事务id的行数据（保证不幻读）
            * 保证读取到的数据是事务开启前的数据
        * 删除版本号为null，或者删除版本号大于当前事务id（保证不读脏）
            * 保证读取到的数据没被删除，或者是被后续事务删除的


    