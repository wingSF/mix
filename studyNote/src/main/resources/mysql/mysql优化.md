* mysql性能优化by seven
* 索引的意义
    * 减少数据的检索量
    * 将随机IO变成顺序IO-----不是很理解
    * 避免使用临时表-----不是很理解
* 极端情况下，平衡二叉树会转化成线性链表，效率基地
* 树的高度会决定IO的次数
* 磁盘交换一次交互，能交换大概4k数据-----不是很理解，数据预读原理
* 列的占用字节数，直接决定以该列为索引，每个节点可以存储多少个关键字
* 平衡二叉树会为了保持平衡会频繁的节点裂解合并
* B+树
    * 左闭合更加适合自增
    * 只有叶子节点才会保存数据
    * 数据区会用链表连接
    * B+树高度较低，查询效率想对于B树更加稳定
        * B树深度不固定，会导致查询效率及其不稳定
> B树与B+树的区别  
B树中搜索可以在非叶子节点中断，B+树的搜索一定要查找到叶子节点才会结束  
B树中，指向叶子节点的数量总是比关键码的数量大1，所以B树会出现在非叶子节点就搜索结束的情况，而B+树的关键码的数量与叶子节点的指针数量是相等的，所有的搜索都在叶子节点命中数据  
优点：B+树的查询效率是稳定的O(logN),而相对于B树则不是很稳定，有可能在非叶子节点命中数据

* mysql engie
    * .frm文件，保存表的定义
    * innodb
        * .ibd文件存储了索引+数据
        * innodb的辅助索引，存储主键索引
    * MyISAM
        * .MYD文件，保存数据
        * .MYI文件，保存索引
        * MyISAM的辅助索引，存储数据文件的地址值
* 列的离散型
    * count(distinct column)/count(column),数值越小，建立索引后效率越高，反之，如果数值较大，mysql查询优化可能不会选择使用索引
* explain
    * possiable key指可能会使用某个索引，但是如果数据区分度不够高，mysql会放弃使用索引，改为全表扫描，及key会是null     
* 联合索引
    * ex: uniqueIndex(column1,column2)
        * 索引节点内容：column1，column2
        * 最左匹配原则
            * 从左开始匹配，直到遇到范围查找结束
            * 如果第一列使用范围查找，无法命中索引
* 覆盖索引
    * 查询结果，可以直接从索引上返回，无需回表操作，效率高的一b
    * select column1，colnmu2 from table；
* hash索引
    * 在Memory引擎中才存在，Innodb和MyISAM中不存在
    * O(1)的查询复杂度，如果范围查找，会退化为O(n)

