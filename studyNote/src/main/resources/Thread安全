线程安全
    问题源起对共享变量的操作，又要快（高并发）还不能出错（线程安全）

    高并发即多线程，多线程就要涉及到Java Memory Model的定义
        Java Memory Model规定，所有的变量都必须存储的在主内存
        线程间的通信采用内存共享方式（另外一种是通知消息）
        每个线程都有自己的工作内存，线程对变量的所有操作（读取/赋值等）都必须在工作内存中完成
        线程的工作内存中保存了 该线程使用到的变量在主内存中存储的副本，可以称之为缓存

        注意：
            一个共享变量
                主内存中存储一份
                工作内容的cache中存一份
                线程执行过程中，会从cache拿一份数据出来在stack中操作
                线程修改一个共享变量数据的过程如下：
                    步骤1              步骤2               步骤3          步骤4      步骤5
                    从主内存读取到cache->从cache读取到stack->在stack中做修改->覆盖cache->再覆盖主内存
                    上述5个步骤很重要，后面的分析都依赖于此

    基于上述模型，会产生一个问题，如果线程a修改了共享变量，需要同步回主内存，如果线程b也缓存了这个变量，需要让b能知道该变量发生变更

    代码级别解决上述俩个问题
        1.Synchronized
            将对共享变量的操作方法提取到一个公共的方法中，然后使用 synchronized 关键字对该方法进行标志
            原理：将对该变量操作的范围固定，然后保证这个范围内的代码执行是单线程的，从而达到安全
            弊端：锁住的范围太广（表面现象），加锁解锁（耗时），线程等待（最耗时）
            从编码角度讲，太局限了，synchronized只能使用与方法，静态代码块，不如Lock灵活
            关键字：多线程并发访问共享资源的时候，需要拿到锁，才可以进入同步代码的代码中去执行
            更关键的：线程要获取   cpu+锁
            最最关键的：经常出现线程获取了cpu但是没有锁，就得让出cpu，一直让，直到拿到锁的线程拿到了cpu才能走下去
        2.volatile（解决 可见性  有序性）
            被volatile标示的共享变量，同时被三个线程T1，T2，T3访问，可以保证如下场景。

                如果T1线程读取共享变量，需要执行步骤1，步骤2，才可以把主内存的数据读取到工作内存。
                如果T1线程对共享变量进行修改，只有执行了步骤5操作，才会把工作内存的数据刷新到主内存，之后T2，T3线程执行步骤2操作的时候，volatiole可以保证重新从主内存中读取到共享变量的新值。
                    StopThreadByVolatileFlag.java
                        说明某个volatile修改的变量，被某个线程修改后，别的线程可以获取到新值，而普通变量没有这种特性
                            很多地方提到的可见性问题

                如果T1线程读取共享变量，执行了步骤1，步骤2，步骤3
                T2线程修改了共享变量的值，并执行了步骤5，这个时候主内存中的值为新值
                此时T1线程如果执行步骤1，步骤2，可以读取到这个新值，但是不巧的是，T1线程执行了步骤4和步骤5，这个时候T1线程就把T2线程的新值覆盖了，线程不安全了！！！
                    MultiThreadGetSum.java
                        说明volatile没办法保证线程安全
                            没有做到线程安全的最核心是因为代码级别a++动作翻译成字节码甚至指令时，会变成上述5个操作中的某几个，即不是cpu级别的原子操作，会被别的线程打断

                针对上一个场景，如果可以将a++的多个步骤合并为一个步骤，即变成一个原子操作，即能实现线程安全
                    AtomicIncrement.java
                        说明 volatile + 对共享数据的原子操作 可以实现线程安全
                            原子操作可以通过java.util.concurrent包下的类实现
                                实现原理CAS（compare and swap）
                                    个人理解：我要把3+1 之前执行步骤5的时候，没有关注save之后，主内存是否是4
                                            如果是cas操作的话，必须保证执行步骤5之后，主内存结果为4，如果不是4，就重新获取变量的值
                                            然后再进行+1，写回内存的操作
                                            即通过自旋将多个操作，从结果上保证了原子操作

            ----------------以上重点关注volatiole的设计之可见性分析（针对单一共享变量的多线程操作）----------------
            ----------------以上重点关注volatiole的设计之有序性分析（针对多个共享变量的多线程操作）----------------

            关于有序性分析，单开一篇，写完回来继续线程安全


















    如何解决上述问题，Java Memory Model给出了8个指令
        lock，unlock
        read，load
        use, assign
        store，write


多线程的代码被cpu执行的时候是一串指令











































/** 突闻高中物理学科卞去世，最开始是不信，而后开始回忆曾今的点滴，虽不是极度震惊，但又些许后怕。父母年纪远大于卞，他的儿子和我是同班同学。心情变化极度复杂，却又无法描述，缅怀恩师，走好   */


