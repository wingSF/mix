# java并发 与 cpu
* java代码执行过程
    * 程序员编写代码
    * 编译器编译.java到.class
    * .class被jvm加载，编程汇编指令
    * cpu执行汇编指令
    > java并发很多依赖与JVM的实现和cpu提供的指令
    
* volatile
    * 表面作用，被volatile修饰的共享变量，当一个线程修改了他的值的时候，其它的线程都能读到这个修改的值
    * 优势:volatile不会出现上下文切换和调度，成本比Synchronized低很多
    * 劣势:不能保证被修饰共享变量的线程安全
    > java语言规范中定义了，线程可以访问共享变量，但是为了保证共享变量被准确和一致性的更新，线程应该通过排他锁的方式获取该变量。java语言提供了volatile，在某些情况下比锁要更加方便。如果一个共享变量被申明为volatile，java内存模型确保所有线程看到这个变量的值是一致的
    * 深入汇编语言和cpu，看看volatile到底是怎么工作的 
        * cpu级别的概念
            * 内存屏障(memory barriers):是一组处理器指令，用于实现对内存操作的顺序控制
            * 缓冲行(cache line):缓存中可以分配的最小单位
            > 原文中的缓冲线是个嘛玩意儿啊？//todo     
            * 原子操作(atomic operations):不可中断一个或一系列操作
            * 缓冲行填充(cache line fill):当处理器识别数据是可以缓存的，就会读取整个缓冲行到适当的缓存
            > ex:通过[缓冲行提升效率](https://mp.weixin.qq.com/s/ODJqoiHYwAhRCMnVjunsbQ) disruptor的RingBuffer vs jdk的ArrayBlockingQueue，详细代码可参考/mix/arithmetic/src/main/java/com/wing/lynne/CacheLinePadding.java  
            jdk7中的LinkedTransferQueue中的PaddedAtomicReference也使用了该机制
            * 缓存命中(cache hit):如果进行高速缓冲行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取数据，而不是从内存中读取
            * 写命中(write hit)://todo
            * 写缺失(write misses the cache)://todo
        * 被volatile的变量在更行的时候会发生哪些操作
            * 会将修改后的值直接刷新到主内存
            * 同时通知其它cpu缓存，该地址对应的缓存值已经被修改，其它cpu在操作该数据时，重新从主内存中获取
            > 前文涉及到的多级缓存，一部分cpu独占，一部分cpu共享
* Synchronized
    * jdk1.6对Synchronized做了大量优化，其目的在于减小获取锁和释放锁的带来的性能消耗，提高获取锁和释放锁的效率。  
    * 减少锁的开销的手动有:偏向锁/轻量级锁/自旋/适应性自旋/锁消除/锁粗化
        * 锁消除
            * 即时编译发现资源没有竞争的情况下，会直接消除同步
                * ex:堆上的数据，都不会逃逸出去被别的线程访问到，那么就是相当于是线程私有的
        * 锁粗化
            * 在一段代码中，出现了多个地方频繁加锁解锁的情况，或者在循环体内部进行加锁操作，这个时候为了减少加锁的次数，虚拟机会对锁的范围进行扩大
            * 前提条件，本来没有线程竞争的地方，却频繁的加锁，虚拟机会对其进行优化，即锁范围扩大
        * 自旋/适应性自旋
            * 参见上面优化的理论依据中的劣势部分的解释
    * 优化前
        * Synchronized如果加在代码段，使用的是monitor enter和monitor exit指令
        * Synchronized如果加在方法，通过给方法增加一个ACC_SYNCHRONIZED标识
        * 弊端
            * java线程会映射到操作系统的原生线程上，对线程的挂起和唤醒都需要操作系统来完成，即需要用户态向内核态进行转变
    * 既然java对象都可以成为锁，那就来看下java对象的结构
        * 如果是数组对象，虚拟机采用3个字宽来存储，如果是非数组对象，虚拟机采用2个字宽来存储，多出来的那个字宽用来存储数组的长度(Array Length)
        * 32位机器中，1字宽为4kb，32bit
        * 第一个字宽存储(Mark Word)，对象的hashcode(25bit)，gc年龄(4bit),锁状态(2bit)，默认位(1bit)
        > 深入理解java虚拟机-周志明版中写默认1bit为0，java并发编程中写默认1bit记录是否是偏向锁，个人觉得后者的说话更加可取。后续内容中采用后者描述
        * 第二个字宽存储(Class Metadata Address)，对象的地址值
    * 锁状态
        * 无锁/偏向锁/轻量级锁/重量级锁
        * 以上是随着竞争，锁升级的过程，锁不可降级
        * 这样做的目的是提高获得锁和释放锁的效率  
    * 偏向锁/轻量级锁/重量级锁
        * 偏向锁   
            * 理论依据:大多数情况下，锁不仅不存在竞争，而且总是由一个线程多次获得
            * 过程
                * 线程先将java对象头中的内容复制到当前线程的栈空间中，记为Lock Record
                * 然后cas方式尝试将线程id存放到对象头中
                * 修改对象头中的偏向锁标识位
                * 之后该线程再次进入同步代码段中，不会由加锁解锁操作，也不会由cas操作，只是简单测试下mark word中的偏向线程id
                * 当别的线程尝试获取锁，偏向模式结束
            > //todo 详细的过程要达到灵魂拷问师通过的标准
            * 作用
                * 提升同步但无竞争情况下的效率
            * jdk6和7默认开启偏向锁，可以通过 -XX:-UseBiasedLocking=false,关闭偏向锁，只有直接进入轻量级锁定状态
            * 适用场景
                * 只有一个线程访问同步代码块                
        * 轻量级锁:相对与重量级锁来说，没有采用互斥量来实现，而是通过cas修改锁即java对象的对象头来实现的一种资源占有方式
            * 理论依据
                * 对于同一个锁，在整个同步周期内都是不存在竞争的或者说发生竞争的概率很小
                * 共享数据的锁定状态只会持续很短的一段时间，为了这段时间去挂起和恢复线程并不值得
            * 过程
                * 线程先将java对象头中的内容复制到当前线程的栈空间中，记为Lock Record
                * 然后cas方式尝试将对象头指向该Lock Record记录
                * 修改对象头中的锁标志位00，表示该对象被轻量级锁定
                * 如果有俩个线程争抢该对象，将变成10，对象头当中存储指向互斥量的指针，其它线程阻塞
                * 解锁过程也是cas替换，将Lock Record更新回对象头，如果成功，则结束，如果失败，则说明有线程被block，需要唤醒//todo 如何唤醒的
            * 作用
                * 减少没有竞争的情况下，锁的性能消耗
            * 适用场景
                * 同步代码块执行很快
        * 重量级锁:使用操作系统的互斥量来实现的传统锁，低效
            * 适用场景
                * 同步代码块执行较慢
    * cas
        * 单核情况下，cas可能无效；但是双核或者多核心的情况下，是存在并行线程的，这个时候某个核上的线程自旋会等待别的核上的线程释放共享资源是有可能的
        * 优势
            * 避免了线程切换的开销
        * 劣势
            * 增加cpu的时间片占用
                * 自旋:如果别的线程占用锁资源的时间较长，则会导致很多次无效果的自旋，可以通过配置修改默认的次数（10次）
                    * 适应性自旋:改进办法，使用自适应的自旋，自旋次数由上次自旋次数决定
                    * jdk中如何实现自旋，部分源码使用了for(;;)，那while(true)可不可以呢？//todo
                    
* 原子操作
    * 不能被进一步分割的最小粒子/不可被中断的一个或一系列操作
    * 为了明白cpu如何实现原子操作，继续引入cpu概念
        * 比较并交换(compare and swap):cas操作需要输入俩个值，一个旧值(期望操作前的值)和一个新值。更新时，先比较当前值是否与期望值一致，如果一致，更新为新值，否则不操作
        * cpu流水线(cpu pipeline)://todo
        * 内存顺序冲突(memory order violation):内存顺序冲突由伪共享(参见上面的缓冲行填充的备注部分)导致，即多个cpu操作了同一个缓冲行中的不同内容，导致某个cpu执行的指令无效，必须清空cpu流水线
    * cpu实现原子操作
        * 总线锁
        * 缓存锁
    * Java的原子操作由锁+循环cas的方式实现
    * cas带来的问题
        * ABA问题，当变量从A变成B，又从B变成A，这个时候新来的线程发现他符合预期的值，就开始更新，但是这其实是不对的。通过加版本号的方式解决，AtomicStampedReference,或者AtomicMarkableReference
        > 举例说明  
        来自知乎的转账问题，假如a账户余额200，ATM取钱100，不巧的是，取钱请求发送了俩次，更不巧的是扣减余额采用了cas操作，更加不巧的是，此时有人给a转了100快，这时候事情就变得有趣了。  
        余额的变化过程是这样的  
        余额200 - 取钱100(第一个请求) = 100
        余额100 + 转账100(朋友转钱) = 200
        余额200 - 取钱100(第二个请求) = 100
        * 循环cas会带来cpu空轮训
        * cas只能操作一个共享变量
            * 解决办法，将多个要操作的变量合并在一起，`AtomicReference`了解下//todo 待深入理解
    * 使用锁机制实现原子操作
        
        
        
        
       
    
        
            