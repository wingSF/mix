# 锁
* 作用:让临界区的代码互斥执行
* 锁释放会把线程对应的本地内存中的共享变量刷新到主内存中
* 锁获取会把线程对应的本地内存中置为无效，从而保证临界区的变量读取可以用主内存中获取。

## ReentrantLock
* 核心方法
    * lock  
    * unlock
* 内部核心类 Sync extends AbstractQueuedSynchronizer
    * 核心实现 FairSync/NonfairSync
    > 在NonfairSync中使用cas操作来更新数据状态
* CAS操作具有volatile读和 volatile写的内存语义
    * cas实际调用的是cmpxchg的指令，根据是否是单处理器运行，确定是否增加lock前缀指令
    * 在Pentium和Pentium之前的处理器，lock指令通过锁总线实现原子操作；从Pentium 4/Intel Xeon及P6处理器开始，使用锁缓存实现，开销更小
    * lock指令
        * 禁止该指令与之前和之后的读写指令重排序
        * 把写缓冲区的数据刷新到内存中
        > 以上俩点做到了类似内存屏障的效果，类似volatile读/写的内存语义
* Concurrent中的实现套路
    * 声明共享变量为volatile
    * CAS更新实现同步
    
# final
* 规则
    * 当final域为基本数据类型时
        * 在构造函数内对一个final域的写入，与随后把被构造对象的引用赋值给一个引用变量，这俩个操作不能重排序
            * JMM禁止编译器把final域的写，重排序到构造方法外面
                * 通过在final域写 和 构造方法返回中间，插入一个 storestore屏障
        * 初次读一个包含final域的对象的引用，与随后初次读这个final域，这俩个操作不能重排序
            * 本身该操作存在间接数据依赖，所以编译器不会进行重排序
            * 但是alpha处理器会进行重排序，所以加入loadload内存屏障，专门对付该类型处理器
    * 当final域为引用数据类型时
        * 在构造函数内对一个final对象的引用的成员域的写入，与随后把被构造对象的引用赋值给一个引用变量，这俩个操作不能重排序
* 最终效果
    * 在引用变量对任意线程可见之前，保证final域已经正确初始化
* 编码注意
    * 不能将被构造对象从构造方法中逃逸（通过this）
    * why
        * 构造方法内部可能会重排序，一旦对象逃逸之后，就会对别的线程可见，导致线程可能读取到初始化之前的默认值
> 在x86处理器中，不会对写-写操作进行重排序，同时保证数据间接依赖，所以写final域的storestore屏障和读final域的loadload屏障都会被省略
* 为什么这么做
    * 在JSR-133之前会读到变化的final域的值，所以做了增强
    * 通过对final域增加读写操作的重排序规则，可以为Java程序员提供初始化安全保证
        * 只要对象是正确构造的(被构造对象的引用在构造方法中没有逸出)
        * 不需要使用同步就可以保证任意线程都能看到这个final域在构造函数中被初始化的值
