# happens before
* happens before是JMM的核心概念
* JMM的设计目标
    * 面向程序员
        * 提供简单可靠的内存模型，易于编程，易于理解
    * 面向计算机
        * 尽量减少对处理器和编译器的束缚，提升执行效率
* happens before对重排序的控制
    * 禁止会改变程序执行结果的重排序
    * 允许不会改变程序执行结果的重排序
> 程序员通过happens before关系来操作内存  
happens before通过限制处理器和编译器来控制重排序  
同时注意，编译器
* 目标
    * 在不改变程序执行结果的前提下，尽可能的提升并行度
    * ex
        * happens before关系保证，正确同步的多线程程序中，a happens before b，那么a的操作结果对b可见
        * as if serial保证，单线程程序的执行结果与顺序执行的结果一致
* 规则(主要保证结果的可见性)
    * 程序顺序规则
        * as if serial规则的封装，即根据书写规则保证
    * 监视器锁规则
        * 解锁 happens before 加锁
    * volatile变量规则
        * 对一个volatile的写 happens before于后续的  读
    * 传递性
    * start规则
        * 线程a内，start线程b，在线程a内start之前的操作对线程b可见
    * join规则
        * 线程a内，线程b.join，在join正确返回后，线程b的操作对线程a可见

# double check
* 为降低类初始化和创建对象的开销，常采用延迟初始化来实现，有一种双重检查锁的方式
* 示例DoubleCheckDemo.class中的代码是存在问题的，因为对象初始化的时候，初始化动作和引用赋值是可能发生重排序的
* 解决办法
    * 使用volatile修饰，可以禁止初始化和引用赋值的重排序
        * 需要jdk5以上版本的支持
        * 支持静态&非静态字段的延迟初始化
    * 使用类初始化机制，可以禁止别的线程看到，对象初始化过程中的重排序操作
        * 只能支持静态字段的延迟初始化

# class load
* 类被初始化的触发条件
    * T是一个类，当创建对象时
    * T是一个类，当它的 静态方法 被 调用 的时候
    * T是一个类，当它的 静态字段 被 赋值 的时候
    * T是一个类，当它的 静态字段 被 使用 的时候，且该字段不是常量
    * T是一个顶级类(top level class)，而且一个断言语句嵌套在T内部被执行
* 初始化过程
    * 在对象初始化是，多个线程争抢类的初始化锁，来控制类或接口的初始化。抢到锁的修改初始化状态state=initializing，没抢到的等待。
    * 设置状态成功的线程执行类的初始化和初始化类中声明的静态字段，其它线程通过状态，在condition上等待
    * 初始化完成的线程修改状态为state=initialized，唤醒在condition上等待的线程
    * 被唤醒的线程结束类的初始化处理
    * 后续线程执行类的初始化(判断状态后，直接结束)
* 
    
       
    