# 第一章
* 并发的目的:为了让程序运行的更快
* 并发的实现手段:多线程
* 并发遇到的问题:
    * 无锁
        * 上下文切换
    * 有锁
        * 死锁
        * 阻塞/等待
    * 都会受到机器资源的限制
    
* 上下文切换
    * 机器通过分配cpu时间片，来执行多线程任务，这个过程叫上下文切换。
    > 并发&并行  
    在单核心cpu上看起来就像一起运行，但实质还是排队执行，叫并发。在多核心cpu上，多线程才是真正的同时执行，叫并行。  
    并发是单核概念;并行是多核概念
    * 谁在切换
        * cpu中的数据被替换
    * 替换了什么
        * 保存了当前线程的内存数据（cpu寄存器/pc计数器）
    * 有什么弊端
        * 频繁的上下文切换，会将cpu的执行时间大幅浪费
        * 我们应该把更多的cpu时间放在业务逻辑的执行上
    * 切换分为哪几类        
        * 进程间切换
            * 进程间的数据是无法共享的
        * 用户态/内核态切换
            * 由于linux系统的限制性，普通的进程访问外部的数据，需要进行系统调用
                * example读取数据，cpu会从用户态，通过系统调用进入内核态，获取到数据后，再恢复为用户态，期间发生俩次上下文切换
            * 可以理解为进程内的切换
        * 线程间切换
            * 由于线程归属与同一个进程，所以线程间的切换，有很多数据是共享的，这也是多线程比多进程高效的核心原因
        * 中断切换
            * 没懂。。。
    * 如何解决或者减少上下文切换的次数
        * 使用无锁并发编程
            * 多线程竞争锁的时候会产生上下文切换，那就减少锁竞争的概率。ex:jdk1.7的ConcurrentHashMap采用分段锁的机制
        * cas算法
            * 更新数据的时候，使用jdk的Atomic包使用cas的操作来更新数据，可以不加锁
            > question:如果自旋了很多次都成功不了，怎么办挂起，后续继续自旋么，如果一直不对，是不是就死循环了
        * 减少线程数量/使用协程
            * 避免创建不必要的线程，常见于系统中大量线程等待状态。ex:线程池的核心线程数和最大线程数原理
            * 协程//todo
            
* 死锁
    * ex:t1线程，t2线程都已经持有了一个各自的锁，然后都想获取对方的锁
    * 如何避免
        * 一个线程不要获取多个锁对象/占用多个资源
        * 如果确实需要多个资源，则扩大锁的范围，一次性锁定多个资源
        * 如果确实一个线程要获取多个资源对象，严格控制加锁的顺序，每个线程都必须保持一致
        * 获取锁的动作，要使用定时锁，必须使用tryLock(long timeout)
        * 代码必须保证锁释放
        
* 资源限制
    * 硬件方面
        * 网络带宽:不会因为多线程就超过带宽限制的上传/下载
        * 硬盘读写速度
        * cpu的处理速度也是有上限的
    * 软件方面
        * 数据库的连接数
        * socket连接数
    * 带来的影响
    > 并发的本质是通过把串行的变成并行的来提升效率，但是由于受限于资源，原本的并行变成了串行，甚至阻塞等待，还增加了上下文切换和资源调度的时间
    * 如何解决
        * 硬件方面
            * 通过多机器并行执行，ex:map-reduce
            * 通过多进程并行执行，ex:fork/join-------//todo笔者自己添加的，还需验证
        * 软件方面
            * 合理的设置连接数的大小
            * 使用连接复用技术              
    
        
    