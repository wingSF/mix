# file结构体
    * 读写指针位置
    * 文件描述符
        * 通过open文件获得
        * 指向文件的地址
            * linux已经将stdin|stdout|stderr分配为0，1，2，所以用户open的第一个会获取到3
        * 每个进程可以打开文件的个数，取决与ulimit -a 中的open file配置
    * 缓冲区
        * 行缓冲
            * 遇到\n，就刷新缓冲区
        * 全缓冲
            * 写满|flush|关闭的时候会刷新缓冲区
# 地址空间
    * 当程序在linux服务器上运行时，会被划分0—4G地址空间，此空间为虚拟地址空间
        * 32位cpu最大寻址空间4G
    * 其中0-3G是用户空间，被用户独占，3G-4G是内核空间，用户无权操作
        * 内核空间->kernal
        * 作用
            * 内存管理|进程管理|驱动管理|虚拟文件系统管理
    * 一般程序不会占用3G的空间，为避免浪费，采用内存映射技术
    * 虚拟内存与物理内存
        * 物理内存就是电脑的配置
        * 虚拟内存则是为进程虚拟的一个空间，本身并不存在
        * 俩者通过MMU（内存地址管理单元），进行虚拟地址映射
            * 将当前程序占用的首地址与内存中的地址做一个映射
    * MMU好处
        * 一个进程占用多少内存，会在物理内存实际分配多少内存，只有在malloc的时候才会真正创建
        * 涉及内核空间，会被复用
        * cpu取指令执行的时候，先访问虚拟内存，通过MMU找到物理内存，然后执行
    * PCB   
        * 记录程序运行的进程号等信息  

# 内存
    * malloc分配时，是按照一页一页分配的，默认一页使用完了，才会再次分配新的
      
# 虚拟内存(交换分区)
    * 当物理内存容量无法满足多个程序的要求时，linux会把部分暂时不运行的程序，转移到硬盘上，释放出内存空间，供需要执行的程序使用
    * 相当于把暂时不运行的任务，转移到磁盘上，这是一种不太推荐的方式，当资源受限的时候，采用此方式
    * 虚拟内存空间设置不宜太大，1.5-2倍的内存空间即可
    * 本身将数据换来换去的就是一种浪费
    
# 文件系统-ext2
* 启动块
    * 保存操作系统信息（多系统）
    * 大小1K
    * pc厂商定义好的，与文件系统类型无关
* 超级块
    * 记录文件系统的版本
    * 记录块大小
* 块组描述符表-GDT
    * 记录块组的使用情况
        * GDT可以用来简单计算磁盘利用率
> 多组之间数据互为备份,super block+GDT
* 快位图-block bit map
    * 该区域的大小，决定了group的大小
    * 第0位对应超级块
    * 在bitmap中被使用的标记1，未被使用的为0
* i节点-inode bit map
    * 记录inode table使用情况
* inode table
    * 多个连续的inode组成
    * 1个inode128字节
    * 一半存放文件属性
    * 一半存放数据块指针
        * 15个指针，一个指针4字节，指向数据块地址
        * 数据指针寻找，0-11为直接寻址，12为一级间接寻址，13为二级间接寻址，14为三级间接寻址
* 数据块-data block
    * 记录文件的数据信息
    * data block是统一编号的，所以当前inode table中的数据库指针可以指向下一个group中的数据块
> 创建文件的时候，先分配inode，然后写data block  
查看文件的时候，也是要读取到data block中的内容  
删除文件的时候，只是修改bit map的情况，但是data block暂时是没有改变的，所以才可以文件恢复
当文件被删除的时候，不要在当前目录下，进行文件操作，使用恢复工具，完成数据恢复动作  
如果你是一个合格IT工作这，删除了不想被恢复，那记得在目录下，多做点文件创建读写操作，这个时候，谁都无法恢复

