# 分布式事务
* what
    * 指数据操作发生在多个节点，如何保证事务的acid，跨db
* 理论
    * 2PC（Two-phase Commit）
        * 通过协调者（Coordinator）像多个节点发起请求，统一提交，或者统一回滚
        * phase
            * prepare
                * 询问事务是否执行成功
                * 可以超时，超时后，大家一起回滚，返回错误
            * commit or rollback
                * 提交或回滚
                * 不撞死不罢休
        * 问题
            * 所有节点同步阻塞
            * 协调者是个单点，跪了就没得玩
            * commit阶段就是个重试，还是可能出现数据不一致问题，
            * 一个跪掉全部回滚，这个代价有点高，对于业务的实际感受快赶上单体应用了
        * 好处
            * 也不是一无是处啊，把资源在prepare阶段占好，统一commit，毕竟commit相比占资源耗时要短很多
    * 3PC
        * 这个听名字就有点热闹了，哈哈～
        * phase
            * canCommit
                * 先询问，排除资源本来就拿不到的场景，直接返回失败
            * preCommit
                * 达到这个状态的说明所有的资源都ok，就等提交了，解决了协调者活过来之后的不知到该怎么办的问题
            * doCommit
        * 问题
            * 环节变成了
        * 好处
            * 协调者不单点，活了之后有状态依据
* 实践
    * AT
        * 只能支持mysql或者带主键的acid数据库
        * 得是java应用
        * seata的实现
            * 一阶段，镜像读，拿到数据，生成undo日志，写入undolog表
                * 向TC申请全局锁
                * 更新和undo一起提交
                * 向TC汇报事务结果
            * 二阶段
                * 回滚
                    * 根据undo日志生成回滚sql
                    * 提交本地事务
                    * 向TC反馈结果
                * 提交
                    * 收到TC的提交请求，放到队列里面，返回成功
                    * 异步删除undo log
    * TCC
        * Try
            * 预留资源
        * Confirm
            * 确认
        * Cancel
            * 撤销
        * 问题
            * 每个业务操作，实现三个动作，简直噩梦
        * 好处
            * 不依赖数据库资源啦
    * saga
        * 依赖回滚，还是tcc的思想
    * XA
        * 要求数据库支持XA
    * 消息事务
        * 基于rocketmq
            * 过程
                * 先发消息
                * 执行本地事务
                    * 事务执行成功后，将消息确认
                    * 事务执行失败，消息abort
        * 柔性事务
            * 允许人工介入或者多次重试，直到达成最后的效果