1.JVM
    java虚拟机在运行java程序过程中会把它所管理的内存区域分为多个不同的数据区域。
    每个数据区域的用途？
    每个数据区域创建及销毁的时间？
    每个数据区域是线程共享？

    根据《Java虚拟机规范（Java SE 7版）》的规范，Java虚拟机所管理的内存讲会包括以下几个运行时数据区域

    方法区    虚拟机栈    本地方法栈    堆    程序计数器

    1.1程序计数器（Program Counter Register）
        只是虚拟机的概念模型，不同的虚拟机会有不同的实现方式
        较小的内存区域
        当前线程所执行的字节码的行号指示器

        字节码解释器：
            通过改变程序计数器的值来选取下一条需要执行的字节码指令
                完成分支、循环、跳转、异常处理、线程恢复等基础功能

        处理器：单核、多核

        对于一个核来讲，某个时刻，只能执行某一个线程中的指令

        关注点：
            程序计数器是线程私有的，随着线程的创建创建，销毁销毁，各个线程独立存储，互不影响
            java虚拟机的多线程是通过线程轮流占有cpu处理时间来实现的

        对于java中非native方法，计数器记录的是当前正在执行的字节码指令的地址值
        对于java中native方法，计数器记录的是undefined

    1.2java虚拟机栈（Java Virtual Machine Stacks）
        线程私有，生命周期与线程一致
        描述java方法执行的内存模型
            每个方法执行的同时会创建一个栈帧（Stack Frame），用于存储
                局部变量表
                    存放编译期可知的各种基本数据类型
                        boolean
                            占字节：1
                        byte,short,int,long
                            占字节：1,2,4,8
                        char
                            占字节：2
                        float,dubbo
                            占字节：4,8
                    对象引用
                        reference类型
                            可能是指向对象起始位置的引用指针
                            可能是指向对象的句柄
                            或其他与对象相关的位置
                    returnAddress
                        指向一个字节码指令的地址
                    单位是Slot,long和dubbo占用俩个Slot，其他只占用1个。
                    所以编译期，局部变量表的空间大小就已经确定，运行期间不会发生变化
                操作数栈
                动态链接
                方法出口
                等信息。

        每个方法从调用直至执行完成的过程，就对应着一个栈帧在虚拟机栈中的入栈到出栈的过程

        如果线程请求的栈深度大于了虚拟机规定的栈深度，StackOverFlowError
        栈大小可以动态扩展，java虚拟机也可以设置栈大小
        栈扩大的时候如果没有足够内存，OutOfMemoryError

    1.3本地方法栈（Native Method Stack）
        与java虚拟机栈类似
            java虚拟机为java方法中非native的方法服务
            本地方法栈为java方法中  native的方法服务
        虚拟机规范对本地方法栈中使用的语言、使用方式和数据结构并没有强制规定
            可以自由实现，sun hotspot直接将俩者合二为一

        如果线程请求的栈深度大于了虚拟机规定的栈深度，StackOverFlowError
        栈大小可以动态扩展，java虚拟机也可以设置栈大小
        栈扩大的时候如果没有足够内存，OutOfMemoryError

    1.4Java堆（Java Heap）
        Java虚拟机所管理内存中最大的一块，虚拟机启动时创建
        线程共享
        用于存放对象实例，几乎所有的对象实例都在这里分配内存
            Java虚拟机规范：
                所有的对象实例以及数组都要在堆上分配，但是随着JIT编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，
            所有的对象都分配在堆上也渐渐变得不是那么‘绝对’了
        Java堆是垃圾收集器管理的主要区域
            从内存回收的角度来看，由于现在的收集器基本都采用分代搜集算法，所以Java堆中还可以细分为：新生代、老年代；
                在细致一点   Eden空间、From Survivor空间、To Survivor空间等
            从内存分配的角度看，线程共享的Java堆中可能会划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）
                注意，该区域线程私有，多个线程同时new对象的解决方案
            总结，无论如何划分，都与存放内容无关，无论哪个区域，存储的都是对象实例，进一步划分的目的是为了更好的回收内存，或者更快的分配内存

    1.5方法区（Method Area）
        线程共享
        用于存储已经被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
        Java虚拟机规范对方法区的限制非常宽松，可以选择不实现垃圾回收。
            HotSpot虚拟机把方法区纳入了GC回收区域，采用永久代实现方法区的垃圾回收，这样就可以像管理堆一样管理方法区
            该区域的垃圾回收行为较少，但数据进入永久代并非‘永久’存在
            该区域的垃圾回收主要目标是常量池的回收和对类型的卸载
        后续永久代将采用Native Memory来替代永久代的实现方式
        该区域无法再分配内存是，OutofMemoryError

    1.6运行时常量池（Runtime Constant Pool）
        运行时常量池是方法区的一部分
        Class文件包括
            类的版本
            字段
            方法
            接口
            常量池
                存放编译器生成的各种字面量和符号引用
            and so on
        类加载到方法区之后，会将Class常量池中的内容存放到运行时常量池.
        Java语言并没有强制要求只有编译期才可以产生常量，所以运行时常量池可以在运行过程中将常量添加进入。

        符号引用：编译期将变量和常量替换为符号引用，因为这个时候不知道引用的位置，只能使用类似ClassName.xxx的方式标识该变量
        直接引用：运行时对象的位置已经确定，将被直接替换为内存中的地址值

        属于方法区的一部分，无法再分配内存的时候，会抛出OutOfMemoryError


    直接内存（direct memory）
        Q1:使用直接内存的函数或者常见函数有哪些(未果)

        不属于虚拟机运行时数据区
        不属于Java虚拟机规范中定义的内存区域
        直接内存的大小与堆内存大小无关，经常会被忽略配置，如果实际占用内存总和大于了物理内存的限制，会OutOfMemoryError

        NIO中的native函数，会在对外开辟直接内存，然后将Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。












