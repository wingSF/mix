该处只介绍算法的思想和发展过程，详细的扔需要认真分析虚拟机实现
1.标记-清除算法 (Mark-Sweep)
    算法分俩阶段
        1.标记
            标记出所有需要回收的对象，标记过程即对象判定过程
        2.清除
            统一回收所有被标记的对象
    算法存在问题
        1.效率问题
            标记和清除的过程效率都不高
            Q：这个感觉是欲加之罪啊，后续再看看有没有能解释的
        2.空间问题
            标记清除之后会产生大量不连续的内存碎片
                极端情况下，内存都被碎片分割，在分配大对象的时候没有足够大的连续空间，将会再次触发垃圾收集动作
2.复制算法(Copy)
    将可用内存按照容量划分为大小相等的俩块，每次只使用其中的一块。当使用的那一块将要写满的时候，将还存活的对象拷贝到另外一块上面去
    每次对整个半区进行回收，没有内存碎片，只需要移动堆顶指针，然后顺序分配对象即可，简单，高效。

    问题1：2G的内存，使用上限为1G，
    问题2：如果不想浪费50%的空间，就需要额外空间来做担保
    问题3：如果对象的存活率比较高，这个时候要复制的对象较多

    优势场景：
        现在的商业虚拟机采用这种算法对 新生代 进行回收，IBM公司的专门研究表明，新生代中的对象98%是“朝生夕死”的，所以在复制的时候，大部分对象都被回收了，只有极少部分的对象依旧存活
        实际执行时，也不是单纯的将内存划分为1:1俩块，而是分为 一块 较大 的 Eden空间 和 俩块  较小 的Survivor空间，比例 8:1:1
        每次GC时，将 Eden+Survivor1中的对象进行回收，将活着的对象一次性拷贝到另外一块Survivor2空间中，然后清理 Eden+Survivor1的空间
        当Survivor空间不够时，需要依赖其他内存(老年代)

    劣势场景：
        老年代，对象存活率高，可能出现100%存活的极端情况
3.标记-整理算法(Mark-Compact)
    算法分俩个阶段
        1.标记
        2.整理
            让所有存活的对象向 一端 移动，然后直接清理掉 端边界以外的内存
4.分代收集算法(Generational Collection)
    根据 对象的存活周期的 不同 将内存划分为几块。
    Java堆分为新生代、老年代，根据不同的分代，采用不同的算法
        新生代
            每次GC都有大量对象被回收，采用复制算法
                付出少量存活对象的复制成本
        老年代
            对象存活率高，且没有担保空间，采用标记-清除或者标记-整理



