# 垃圾收集(Garbage Collection) 简称GC
* GC的任务
    * 哪些内存需要回收
    * 什么时候回收
    * 如何回收
* 程序计数器、虚拟机栈、本地方法栈3个区域
    * 由于内存的分配和回收都具备确定性，且随着线程的产生而产生，随着线程的销毁而销毁，所以不需要过多考虑
* 判定对象的死活
    * 引用计数法（Reference Counting）
        * 给对象添加一个引用计数器，每当有一个地方引用它时，计数器就+1，引用失效时，计数器-1，当引用为0个时，对象不再被使用
        * 解决不了的问题，对象之间相互循环引用
    * 可达性分析算法（Reachability Analysis）
        * 通过一系列的称为“GC Roots”的对象作为起始点，从这个节点开始向下搜索，搜索所走过的路径称为应用链（Reference Chain）
        * 当一个对象到GC Roots没有任何引用链的相连，即从GC Roots到对象不可达时，证明该对象不可用，判定可回收。
        * 可以作为GC Roots的对象
            * 虚拟机栈（栈帧中的本地变量表）中引用的对象
            * 方法区中的类静态属性引用的对象
            * 方法区中的常量引用的对象
            * 本地方法栈中JNI（即一般说的Native方法）引用的对象

        > Q:上面这几个对象到对象没有引用链就可以回收了么？
* 引用
    * JDK1.2之前
        * reference类型的数据中存储的数值代表的是另外一个内存的起始地址，就称这块内存代表着一个引用
        * 问题
            * 只有俩种状态 被引用和没有被引用
            * 当描述下面场景时（类似缓存），无法满足
                * 当内存空间足够时，保留在内存中；
                * 如果垃圾回收后，内存空间扔紧张，就回收这些对象
    * JDK1.2之后
        * 强引用（Strong Reference）
            * Object object = new Object()
        * 软引用（Soft）
            * 描述一些还有用但并非必需的对象
            * 即将内存溢出的时候，会将这些对象列进回收范围，进行二次回收。如果回收后，还没有足够的内存，就会抛出内存溢出异常
        * 弱引用（Weak）
            * 描述非必须对象
            * 被弱引用关联的对象只能生存到下一次垃圾收集发生之前。下次回收时，无论内存是否足够，都会回收只被弱引用关联着的对象
        * 虚引用（Phantom）
            * 一个对象是否有虚引用的存在，完全不会对对象的生存有影响。
            * 无法通过虚应用来获取一个对象实例
            * 设置虚引用的唯一目的是这个对象被收集器回收的时候能收到一个通知
            > Q:这个通知是怎么发的，通知谁的
        * 总结
            > 强弱软虚是顺序，gc不能回收强，如果空间不够可以回收弱，只要gc就会干掉软和虚，利用虚可以在被gc的时候收到一个通知
* 回收判定
    * 可达性算法判定不可达的对象，也不一定“非死不可”。
    * 要真正判定一个对象的死亡，至少 要经历 俩次标记过程
        * 对象在可达性算法分析后发现没有与GC Roots相连接的引用链
            * 将会被第一次标记并且进行一次筛选
                * 筛选是否有必要执行finalize()方法
                    * 以下俩种将被视为没有必要执行
                        * 对象没有覆盖finalize()方法
                        * finalize()方法已经被虚拟机调用过
                    * 如果有必要
                        * 对象将被放置到一个叫做F-Queue的队列当中，并在稍后由虚拟机自动建立的、低优先级的Finalize线程去执行
                        * 执行过程
                            * 虚拟机会调用finalize()方法，当并不承诺会等待它运行结束
                            * 如果finalize()方法执行缓慢，或者死循环，将会导致整个队列处于长时间的等待，影响整体GC进度
            * 第二次筛选
                * GC将对F-Queue中的对象进行第二次小规模的标记，如果对象仍不可达，将会被回收
                > 此处是对象最后自救的机会，如果可以与引用链上的某个对象建立联系，即可逃脱GC，会从集合中移除。可以通过重新finalize方法做到，这种方式只能自救一次，因为finalize()方法只会被系统调用一次
* 方法区的回收
    * 主要回收内容
        * 废弃常量
            * 系统中没有任何一个引用指向该常量
        * 无用的类
            * 条件1：该类的所有实例都已经被回收，即Java堆中不存在任何该类的实例
            * 条件2：加载该类的ClassLoader已经被回收
            * 条件3：该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法
            * 满足以上3个条件，才 可以 回收。是否回收还要受jvm参数-Xnoclassgc参数的控制
            * 在大量使用反射、动态代理、CGLib的ByteCode框架、动态生成jsp以及OSGI这类频繁自定义ClassLoader的场景都需要有类卸载功能




