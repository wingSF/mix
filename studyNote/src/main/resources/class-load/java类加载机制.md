# 类加载机制
* java加载类到运行的全过程
    * 编译成class文件
    > javap -v 可以生成字节码文件
    * java虚拟机启动
        * 创建引导类加载器
        * 调用Launcher类 getLauncher
        * 加载class文件，变成class meta data放到内存中
            * 加载
                * 磁盘到内存
            * 验证
                * ex:cafe babe，字节码文件开头格式
                * 验证文件内容是否符合java虚拟机规范
            * 准备
                * 静态变量初始化赋值
            * 解析
                * 将符号引用替换为直接引用，这个过程叫静态链接，ex：main方法符合替换为内存地址
                * 实例变量的调用方法，会在运行时，进行替换，这个叫动态链接
            * 初始化
                * 静态变量真正赋值
* 类加载器
    * jvm生成的类加载器
        * 引导类加载器BootStrap
            * c++语言实现
            * 加载jre/lib目录下的类
                * rt.jar|charsets.jar
            * todo java9之后模块化下如何加载的
        * 扩展类加载器Ext
            * 加载jre/ext目录下的类
        * 应用程序类加载器App
            * 加载ClassPath路径下的类
    * 自定义类加载器
        
    * 双亲委派机制
        * 过程
            * 先查看加载过的集合，有则返回
            * 没有，交给父类去加载
                * 父类查看加载过的集合，有则返回
                * 没有交给父类去加载
                    * 顶层parquet如果没有加载成功，则最初的自己加载
        * 核心方法
            * loadClass 根据路径加载文件
                * findClass 子类加载器寻找class
                    * defineClass  根据文件生成Class对象
        * 为什么
            * 沙箱安全机制
                * 保证了jdk的核心类由jdk的加载器加载，保证同包同名的类不会被自定义类加载器，然后覆盖jdk的class文件
            * 避免类的重复加载
                * 如果父加载器加载成功，则子加载器不需要自己加载
    * 类被加载到方法区
        * 内容
            * 运行时常量池、类型信息、字段信息、方法信息、类加载器引用、实例对象引用
* 自定义类加载器
    * 操作
        * 继承ClassLoader
        * 实现findClass
    * 多版本类共存 & 隔离
        * tomcat下的俩个应用依赖不同的spring版本
    * 打破双亲委派
        * 将loadClass方法做重新实现，把原有的双亲委派的相关逻辑删除